<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CodegenCS</name>
    </assembly>
    <members>
        <member name="T:CodegenCS.BaseCodegenContext`1">
            <summary>
            BaseCodegenContext keeps track of multiple files which can be saved at once in the output folder.
            </summary>
            <typeparam name="O">Class of OutputFiles. Should inherit from CodegenOutputFile</typeparam>
        </member>
        <member name="F:CodegenCS.BaseCodegenContext`1._outputFiles">
            <summary>
            Output files indexed by their relative paths
            </summary>
        </member>
        <member name="P:CodegenCS.BaseCodegenContext`1.Errors">
            <summary>
            If your template finds any error you can just append the errors here in this list <br />
            SaveFiles() does not work if there is any error.
            </summary>
        </member>
        <member name="P:CodegenCS.BaseCodegenContext`1.OutputFiles">
            <summary>
            Output files
            </summary>
        </member>
        <member name="P:CodegenCS.BaseCodegenContext`1.OutputFilesRelative">
            <summary>
            Output files, indexed by their relative paths
            </summary>
        </member>
        <member name="M:CodegenCS.BaseCodegenContext`1.OutputFilesAbsolute(System.String)">
            <summary>
            Output files, indexed by their absolute paths
            </summary>
        </member>
        <member name="M:CodegenCS.BaseCodegenContext`1.#ctor">
            <summary>
            Creates new in-memory context.
            </summary>
        </member>
        <member name="M:CodegenCS.BaseCodegenContext`1.SaveFiles(System.String)">
            <summary>
            Saves all files in the outputFolder. <br />
            According to the RelativePath of each file they may be saved in different folders
            </summary>
            <param name="outputFolder"></param>
        </member>
        <member name="M:CodegenCS.BaseCodegenContext`1.SaveFiles">
            <summary>
            Saves all files in the current directory. <br />
            According to the RelativePath of each file they may be saved in different folders
            </summary>
        </member>
        <member name="M:CodegenCS.BaseCodegenContext`1.GetUnknownFiles(System.String)">
            <summary>
            After calling SaveFiles() you may decide to clean-up the Outputfolder (assuming it only has code-generation output). <br />
            This returns all files which are in the Outputfolder (and subfolders) and which were NOT generated as part of this Context. <br />
            Beware that files which are deleted using File.Delete do NOT get moved to Recycle bin.
            </summary>
            <returns></returns>
        </member>
        <member name="T:CodegenCS.CodegenContext">
            <summary>
            CodegenContext keeps track of multiple files which can be saved at once in the output folder.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenContext.#ctor">
            <inheritdocs />
        </member>
        <member name="P:CodegenCS.CodegenContext.Item(System.String)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="T:CodegenCS.CodegenContext`1">
            <summary>
            CodegenContext keeps track of multiple files which can be saved at once in the output folder, <br />
            while also tracking the type for each output file
            </summary>
            <typeparam name="FT">Enum which defines the Types that each file can have</typeparam>
        </member>
        <member name="P:CodegenCS.CodegenContext`1._defaultType">
            <summary>
            Default Type for new OutputFiles
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenContext`1.#ctor(`0)">
            <summary>
            Creates new in-memory context.
            </summary>
            <param name="defaultType">Default Type for files</param>
        </member>
        <member name="P:CodegenCS.CodegenContext`1.Item(System.String)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
            <param name="relativePath"></param>
            <returns></returns>
        </member>
        <member name="P:CodegenCS.CodegenContext`1.Item(System.String,`0)">
            <summary>
            Output files are indexed by their relative path. <br />
            If context doesn't have an OutputFile with this relative path, a new one will automatically be created
            </summary>
            <param name="relativePath"></param>
            <param name="fileType"></param>
            <returns></returns>
        </member>
        <member name="T:CodegenCS.CodegenOutputFile">
            <summary>
            CodegenTextWriter with added properties that describe Outputfile location (RelativePath)
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenOutputFile.RelativePath">
            <summary>
            Relative path of the output file (relative to the outputFolder)
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenOutputFile.#ctor(System.String)">
            <summary>
            Creates a new OutputFile, with a relative path
            </summary>
            <param name="relativePath"></param>
        </member>
        <member name="T:CodegenCS.CodegenOutputFile`1">
            <summary>
            CodegenTextWriter with added properties that describe Outputfile location (RelativePath) <br />
            and type of output (regarding .NET Project - if file is Compiled, NotCompiled, etc)
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenOutputFile`1.FileType">
            <summary>
            Type of file
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenOutputFile`1.#ctor(System.String,`0)">
            <summary>
            Creates a new OutputFile, with a relative path
            </summary>
            <param name="relativePath"></param>
            <param name="fileType"></param>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter">
            <summary>
            This text writer has some features to help code-generation tools: <br />
            - Will keep track of "Indent Levels", and will write whitespace-indents accordingly to the current level. <br />
              It's possible to explicitly increase/decrease indent level <br />
              It's possible to change the IndentString <br />
              It's possible to increase level using "using (writer.WithIndent()) {...}". <br />
              There's a shortcut to start C-style blocks: using (writer.WithCStyleBlock($"public class {myClass}")). Will automatically start "{" and close with "}" <br /><br />
              
            - Allows to execute "inline actions", which mean that writer will save the current cursor position, and will run the action which may write a string. <br />
              If the string has multiple lines, all lines starting from the second will "preserve" the same indent (cursor position) that was there when we started writing the first line. <br />
              This means that it's possible to embed blocks "inline", while preserving the correct indent where the block should start. <br />
               This allow us to use any kind of "template include" functions without having to manually control indentation. <br />
               In case CodegenTextWriter uses these inline actions to write string-interpolation-based templates, but we could also use Razor, Dotliquid, Scriban, or any other template engine. <br /><br />
            
            - Allows to write complex templates using pure C# language and interpolated strings. <br />
              Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments.  <br />
              Since we also control indentation (and preserve indentation even when we run "inline actions" in the middle of the template), this works like a charm. <br /><br />
              
            - For convenience, all multi-line string blocks will have the first empty line removed and Left Padding removed. <br />
              This means that you can write the multi-line strings with any number of padding spaces, and yet those spaces will be ignored - so you can align the  <br />
              generated code with the outer control code.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._innerWriter">
            <summary>
            CodegenTextWriter will always write to an inner TextWriter. <br />
            This TextWriter can be explicitly defined; <br />
            Can be StreamWriter writing to a file; <br />
            Or can be an in-memory StringWriter.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._lineBreaksRegex">
            <summary>
            Identify all types of line-breaks
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._normalizeLineEndings">
            <summary>
            If true, will normalize line breaks by replacing different styles (\n, \r\n, \r, etc) by _innerWriter.NewLine
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehavior">
            <summary>
            How multi-line text blocks are adjusted
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.MultilineBehaviorType">
            <summary>
            How multi-line text blocks are adjusted
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.None">
            <summary>
            Do not remove manipulate multi-line text blocks (write them as they are). <br />
            You'll have to handle mixed indentation levels for text blocks and outer control code.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPadding">
            <summary>
            Will remove the left padding of multi-line text blocks, by "untabbing" the block until some row "touches" the margin.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPaddingAndRemoveFirstEmptyLine">
            <summary>
            Will remove left padding and will remove the first empty line
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.CurlyBracesStyleType">
            <summary>
            How Curly-Braces are written
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.CurlyBracesStyleType.C">
            <summary>
            K&amp;R style (Kernighan &amp; Ritchie Style). <br />
            Used in most C/C++/C# code: <br /> 
            - There's a new line before opening curly braces. <br />
            - There's a new line after closing curly braces.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.CurlyBracesStyleType.Java">
            <summary>
            Java style: <br />
            - No new line before opening curly braces <br />
            - There's a new line after closing curly braces. 
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.CurlyBracesStyle">
            <summary>
            How Curly-Braces are written
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._encoding">
            <summary>
            Encoding
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._currentLine">
            <summary>
            This keeps tracks of what was written to the current line, NOT COUNTING indent-strings which were generated by this text writer.
            Example: if this text writer was already in IndentLevel 1 (4 spaces) when it started rendering a template, and the template opens a nested if block (adding 1 more indent level, totalling 8 spaces),
            This will be 4 (4 extra spaces not counting inherited indent).
            If we render an inner template (e.g. @Include ("SubTemplate")), the subtemplate should honor BOTH the current indent level and also the number of spaces before the template was included.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor">
            <summary>
            New CodegenTextWriter writing to an in-memory StringWriter (using UTF-8 encoding). <br />
            You may choose when to save this file.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.String)">
            <summary>
            New CodegenTextWriter writing directly to a file. <br />
            Default encoding is UTF-8.
            </summary>
            <param name="filePath">Target file</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.String,System.Text.Encoding)">
            <summary>
            New CodegenTextWriter writing directly to a file. 
            </summary>
            <param name="filePath">Target file</param>
            <param name="encoding">Encoding</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.#ctor(System.IO.TextWriter)">
            <summary>
            New CodegenTextWriter writing to another (inner) textWriter
            </summary>
            <param name="textWriter">Inner TextWriter to write to</param>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.NewLine">
            <summary>
            The default line terminator string is a carriage return followed by a line feed ("\r\n"). <br />
            You may override it (Unix uses "\n", Apple use "\r"). <br />
            PS: Null will be replaced by the default terminator (use empty if appropriate).
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.Encoding">
            <summary>
            The character encoding in which the output is written.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Close">
            <summary>
            Closes the current writer and releases any system resources associated with the writer.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Flush">
            <summary>
            Clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.Dispose(System.Boolean)">
            <summary>
            Clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._levelIndent">
            <summary>
            Each level of indentation may have it's own indentation marker <br />
            e.g. one block may have "    " (4 spaces), while other may have "-- " (SQL line-comment), etc.
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.IndentLevel">
            <summary>
            Current IndentLevel
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenTextWriter.IndentString">
            <summary>
            Default Indentation marker is 4 strings. <br />
            You can change to whatever you want
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.IncreaseIndent">
            <summary>
            Increases indentation level
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.DecreaseIndent">
            <summary>
            Decreases indentation level
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ExecuteInlineAction(System.Action)">
            <summary>
            If the current line has some manually-written whitespace, this method will "save" current cursor position, and in case the inline action writes a multi-line text,
            the subsequent lines (after the first) will "preserve" the cursor position by adding this extra indent.
            ("manually-written whitespace" does not count the automatic indents written by this class).
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent">
            <summary>
            Increases the indent level, and when disposed will decrease it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent(System.String,System.String)">
            <summary>
            Opens a new indented Block. Will automatically handle increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent. <br />
            This method will automatically write a line break right before the indented block starts, but will not automatically add a line break after it ends.
            </summary>
            <param name="beforeBlock">Optional - you can specify something to be written BEFORE the indented block starts (before the automatic line break, yet with outer indentation)</param>
            <param name="afterBlock">Optional - you can specify something to be written immediately AFTER the block finishes (back with outer indentation)
            If you're closing with a curly brace you'll probably want to add a line-break after that curly brace.
            </param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteIndent">
            <summary>
            This writes the whole indentation level (e.g. if indent level is 2 it will be 2 levels of 4 spaces each) //TODO: WriteIndent(levels)?
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCurlyBraces(System.String,System.Nullable{CodegenCS.CodegenTextWriter.CurlyBracesStyleType})">
            <summary>
            Opens a new indented Curly-Braces Block. Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent. <br />
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the indented block starts (before curly braces).</param>
            <param name="style">How Curly-Braces are written. If not defined will use current CurleBracesStyleType property (default is C-Style, which starts the curly braces in its own line) </param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock(System.String)">
            <summary>
            Opens a new indented C-Style Block. Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the block starts (before curly braces)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithJavascriptBlock(System.String)">
            <summary>
            Opens a new indented Java-Style Block. Will automatically handle opening and closing of curly braces, linebreaks, and increasing/decreasing indent.
            Should be disposed (use "using" block) to correctly close braces and decrease indent.
            </summary>
            <param name="beforeBlock">Optional - you can specify what is written BEFORE the block starts (before curly braces)</param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteWithIndents(System.String)">
            <summary>
            This is the "heart" of this class. Basically, we split any multi-line string, and write line by line. 
            Before writing each new line we write the indent block, which could for example be 8 spaces (4 spaces in first indent level and 4 spaces for second indent level),
            or 2 tabs (one for each indent level), or any combination.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteFormattable(System.String,System.Object[])">
            <summary>
            This is the "heart" of this class. Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments. 
            The idea of writing Func&lt;FormattableString&gt; is that we do NOT evaluate the {arguments} BEFORE the outer string is being written - they are only evaluated when needed
            so we can capture the cursor position in current line, and preserve-it if the arguments render multi-line strings
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.SaveToFile(System.String,System.Boolean)">
            <summary>
            Writes current content (assuming it was in-memory writer) to a new file. If the target file already exists, it is overwritten. <br />
            </summary>
            <param name="path">Absolute path</param>
            <param name="createFolder">If this is true (default is true) and target folder does not exist, it will be created</param>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.GetContents">
            <summary>
            Get full contents of current Writer
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.AdjustMultilineString(System.String)">
            <summary>
            Given a text block (multiple lines), this removes the left padding of the block, by calculating the minimum number of spaces which happens in EVERY line.
            Then, this method writes one by one each line, which in case will respect the current indent.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="T:CodegenCS.MSBuildActionType">
            <summary>
            All files in a Visual Studio project have a build action. The build action controls what happens to the file when the project is compiled. <br />
            The most common action (like for compiling CS files) is Compile.
            </summary>
        </member>
        <member name="F:CodegenCS.MSBuildActionType.None">
            <summary>
            The file isn't part of the build in any way. This value can be used for documentation files such as "ReadMe" files, for example.
            </summary>
        </member>
        <member name="F:CodegenCS.MSBuildActionType.Compile">
            <summary>
            The file is passed to the compiler as a source file.
            </summary>
        </member>
        <member name="F:CodegenCS.MSBuildActionType.Content">
            <summary>
            A file marked as Content can be retrieved as a stream by calling Application.GetContentStream.  <br />
            For ASP.NET projects, these files are included as part of the site when it's deployed.
            </summary>
        </member>
        <member name="F:CodegenCS.MSBuildActionType.EmbeddedResource">
            <summary>
            The file is passed to the compiler as a resource to be embedded in the assembly.  <br />
            You can call System.Reflection.Assembly.GetManifestResourceStream to read the file from the assembly.
            </summary>
        </member>
        <member name="F:CodegenCS.MSBuildActionType.NonProjectItem">
            <summary>
            Special enum which means that the file will NOT be added to the CSPROJ <br />
            For .NET Framework projects (not NET Core) this means that the file will NOT be added to the CSPROJ (even if you use MSBuildProjectEditor) <br />
            For .NET Core projects (where all files are automatically considered as compilable except if explicitly removed) this means that the file will be explicitly REMOVED from the CSPROJ.
            </summary>
        </member>
        <member name="T:CodegenCS.MSBuildCodegenContext">
            <summary>
            MSBuildCodegenContext keeps track of multiple files which can be saved at once in the output folder, <br />
            while also tracking the MSBuild action for each output file
            </summary>
        </member>
        <member name="M:CodegenCS.MSBuildCodegenContext.#ctor">
            <inheritdocs />
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.AddItem(System.String,CodegenCS.MSBuildActionType,System.String)">
            <summary>
            Adds a single item, optionally dependent of a parent item (DependentUpon). 
            </summary>
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.RemoveUnusedDependentItems(System.String)">
            <summary>
            Given an item in the project, will remove all items which depend on this parent item, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.RemoveUnusedItems(System.String)">
            <summary>
            Given a folder in the project, will remove all items which are under this folder, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.Database.Execute(System.String,System.Object,System.Data.IDbTransaction,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Creates a raw SqlConnection to the database. This is for using Dapper or raw ADO.NET.
            Don't forget to wrap your connection inside a "using" statement, to automatically close/dispose connection at end:
            using (var conn = DB.CreateConnection())
            {
               ...
            }
            </summary>
            <returns></returns>
            <summary>
            Execute parameterized SQL
            </summary>
            <returns>Number of rows affected</returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Execute``1(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Execute parameterized SQL, returning the data typed as per T
            </summary>
            <returns>List of Entities of type T</returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Query``1(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
             Executes a query, returning the data typed as per T
            </summary>
            <returns>
            A sequence of data of the supplied type; if a basic type (int, string, etc) is
             queried then the data from the first column in assumed, otherwise an instance
             is created per row, and a direct column-name===member-name mapping is assumed
             (case insensitive).
            </returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Query(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
             Return a sequence of dynamic objects      <para /> 
             Example:
             var tables = DB.Query("SELECT * FROM sys.tables");
             foreach(var table in tables) Response.WriteLine(table.Name);  <para /> 
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Pluralize(System.String)">
            <summary>
                Pluralizes a word.
            </summary>
            <example>
                inflect.Pluralize("search").ShouldBe("searches");
                inflect.Pluralize("stack").ShouldBe("stacks");
                inflect.Pluralize("fish").ShouldBe("fish");
            </example>
            <param name="word">The word to pluralize.</param>
            <returns>The pluralized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Singularize(System.String)">
            <summary>
                Singularizes a word.
            </summary>
            <example>
                inflect.Singularize("searches").ShouldBe("search");
                inflect.Singularize("stacks").ShouldBe("stack");
                inflect.Singularize("fish").ShouldBe("fish");
            </example>
            <param name="word">The word to signularize.</param>
            <returns>The signularized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Titleise(System.String)">
            <summary>
                Titleises the word. (title => Title, the_brown_fox => TheBrownFox)
            </summary>
            <example>
                inflect.Titleise("some title").ShouldBe("Some Title");
                inflect.Titleise("some-title").ShouldBe("Some Title");
                inflect.Titleise("sometitle").ShouldBe("Sometitle");
                inflect.Titleise("some_title:_the_beginning").ShouldBe("Some Title: The Beginning");
            </example>
            <param name="word">The word to titleise.</param>
            <returns>The titleised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Humanise(System.String)">
            <summary>
                Humanizes the word.
            </summary>
            <example>
                inflect.Humanise("some_title").ShouldBe("Some title");
                inflect.Humanise("some-title").ShouldBe("Some-title");
                inflect.Humanise("Some_title").ShouldBe("Some title");
                inflect.Humanise("someTitle").ShouldBe("Sometitle");
                inflect.Humanise("someTitle_Another").ShouldBe("Sometitle another");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to humanise.</param>
            <returns>The humanized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Pascalise(System.String)">
            <summary>
                Pascalises the word.
            </summary>
            <example>
                inflect.Pascalise("customer").ShouldBe("Customer");
                inflect.Pascalise("customer_name").ShouldBe("CustomerName");
                inflect.Pascalise("customer name").ShouldBe("CustomerName");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to pascalise.</param>
            <returns>The pascalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Camelise(System.String)">
            <summary>
                Camelises the word.
            </summary>
            <example>
                inflect.Camelise("Customer").ShouldBe("customer");
                inflect.Camelise("customer_name").ShouldBe("customerName");
                inflect.Camelise("customer_first_name").ShouldBe("customerFirstName");
                inflect.Camelise("customer name").ShouldBe("customer name");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to camelise.</param>
            <returns>The camelised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Underscore(System.String)">
            <summary>
                Underscores the word.
            </summary>
            <example>
                inflect.Underscore("SomeTitle").ShouldBe("some_title");
                inflect.Underscore("someTitle").ShouldBe("some_title");
                inflect.Underscore("some title that will be underscored").ShouldBe("some_title_that_will_be_underscored");
                inflect.Underscore("SomeTitleThatWillBeUnderscored").ShouldBe("some_title_that_will_be_underscored");
            </example>
            <param name="pascalCasedWord">The word to underscore.</param>
            <returns>The underscored word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Capitalise(System.String)">
            <summary>
                Capitalises the word.
            </summary>
            <example>
                inflect.Capitalise("some title").ShouldBe("Some title");
                inflect.Capitalise("some Title").ShouldBe("Some title");
                inflect.Capitalise("SOMETITLE").ShouldBe("Sometitle");
                inflect.Capitalise("someTitle").ShouldBe("Sometitle");
                inflect.Capitalise("some title goes here").ShouldBe("Some title goes here");
            </example>
            <param name="word">The word to capitalise.</param>
            <returns>The capitalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Uncapitalise(System.String)">
            <summary>
                Uncapitalises the word.
            </summary>
            <example>
                inflect.Uncapitalise("Some title").ShouldBe("some title");
                inflect.Uncapitalise("Some Title").ShouldBe("some Title");
                inflect.Uncapitalise("SOMETITLE").ShouldBe("sOMETITLE");
                inflect.Uncapitalise("someTitle").ShouldBe("someTitle");
                inflect.Uncapitalise("Some title goes here").ShouldBe("some title goes here");
            </example>
            <param name="word">The word to uncapitalise.</param>
            <returns>The uncapitalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Ordinalise(System.String)">
            <summary>
                Ordinalises the number.
            </summary>
            <example>
                inflect.Ordinalise(0).ShouldBe("0th");
                inflect.Ordinalise(1).ShouldBe("1st");
                inflect.Ordinalise(2).ShouldBe("2nd");
                inflect.Ordinalise(3).ShouldBe("3rd");
                inflect.Ordinalise(101).ShouldBe("101st");
                inflect.Ordinalise(104).ShouldBe("104th");
                inflect.Ordinalise(1000).ShouldBe("1000th");
                inflect.Ordinalise(1001).ShouldBe("1001st");
            </example>
            <param name="number">The number to ordinalise.</param>
            <returns>The ordinalised number.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Ordinalise(System.Int32)">
            <summary>
                Ordinalises the number.
            </summary>
            <example>
                inflect.Ordinalise("0").ShouldBe("0th");
                inflect.Ordinalise("1").ShouldBe("1st");
                inflect.Ordinalise("2").ShouldBe("2nd");
                inflect.Ordinalise("3").ShouldBe("3rd");
                inflect.Ordinalise("100").ShouldBe("100th");
                inflect.Ordinalise("101").ShouldBe("101st");
                inflect.Ordinalise("1000").ShouldBe("1000th");
                inflect.Ordinalise("1001").ShouldBe("1001st");
            </example>
            <param name="number">The number to ordinalise.</param>
            <returns>The ordinalised number.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Dasherise(System.String)">
            <summary>
                Dasherises the word.
            </summary>
            <example>
                inflect.Dasherise("some_title").ShouldBe("some-title");
                inflect.Dasherise("some-title").ShouldBe("some-title");
                inflect.Dasherise("some_title_goes_here").ShouldBe("some-title-goes-here");
                inflect.Dasherise("some_title and_another").ShouldBe("some-title and-another");
            </example>
            <param name="underscoredWord">The word to dasherise.</param>
            <returns>The dasherised word.</returns>
        </member>
    </members>
</doc>

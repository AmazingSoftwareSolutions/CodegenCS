<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CodegenCS</name>
    </assembly>
    <members>
        <member name="P:CodegenCS.CodegenContext.OutputFiles">
            <summary>
            Output files, indexed by their relative paths
            </summary>
        </member>
        <member name="P:CodegenCS.CodegenContext.OutputFilesAbsolute">
            <summary>
            Output files, indexed by their absolute paths
            </summary>
        </member>
        <member name="F:CodegenCS.OutputFileType.NonProjectItem">
            <summary>
            File is generated but is not added to the project
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter">
            <summary>
            This text writer has some features to help code-generation tools:
            - Will keep track of "Indent Levels", and will write whitespace-indents accordingly to the current level.
              It's possible to explicitly increase/decrease indent level
              It's possible to change the IndentString
              It's possible to increase level using "using (writer.WithIndent()) {...}".
              There's a shortcut to start C-style blocks: using (writer.WithCStyleBlock($"public class {myClass}")). Will automatically start "{" and close with "}"
              
            - Allows to execute "inline actions", which mean that writer will save the current cursor position, and will run the action which may write a string.
              If the string has multiple lines, all lines starting from the second will "preserve" the same indent (cursor position) that was there when we started writing the first line.
              This means that it's possible to embed blocks "inline", while preserving the correct indent where the block should start.
               This allow us to use any kind of "template include" functions without having to manually control indentation.
               In case CodegenTextWriter uses these inline actions to write string-interpolation-based templates, but we could also use Razor, Dotliquid, Scriban, or any other template engine.
            
            - Allows to write complex templates using pure C# language and interpolated strings.
              Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments. 
              Since we also control indentation (and preserve indentation even when we run "inline actions" in the middle of the template), this works like a charm.
              
            - For convenience, all multi-line string blocks will have the first empty line removed and Left Padding removed.
              This means that you can write the multi-line strings with any number of padding spaces, and yet those spaces will be ignored - so you can align the 
              generated code with the outer control code.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._normalizeLineEndings">
            <summary>
            If true, will normalize line breaks by replacing different styles (\n, \r\n, \r, etc) by _innerWriter.NewLine
            </summary>
        </member>
        <member name="T:CodegenCS.CodegenTextWriter.MultilineBehaviorType">
            <summary>
            How multi-line text blocks are adjusted
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPadding">
            <summary>
            Will remove the left padding of multi-line text blocks, by "untabbing" the block until some row "touches" the margin.
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter.MultilineBehaviorType.TrimLeftPaddingAndRemoveFirstEmptyLine">
            <summary>
            Will remove left padding and will remove the first empty line
            </summary>
        </member>
        <member name="F:CodegenCS.CodegenTextWriter._currentLine">
            <summary>
            This keeps tracks of what was written to the current line, NOT COUNTING indent-strings which were generated by this text writer.
            Example: if this text writer was already in IndentLevel 1 (4 spaces) when it started rendering a template, and the template opens a nested if block (adding 1 more indent level, totalling 8 spaces),
            This will be 4 (4 extra spaces not counting inherited indent).
            If we render an inner template (e.g. @Include ("SubTemplate")), the subtemplate should honor BOTH the current indent level and also the number of spaces before the template was included.
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.ExecuteInlineAction(System.Action)">
            <summary>
            If the current line has some manually-written whitespace, this method will "save" current cursor position, and in case the inline action writes a multi-line text,
            the subsequent lines (after the first) will "preserve" the cursor position by adding this extra indent.
            ("manually-written whitespace" does not count the automatic indents written by this class).
            </summary>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithIndent">
            <summary>
            Increases the indent level, and when disposed will decrease it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock">
            <summary>
            Opens a C-style Block (Compound Statement) which starts with curly-braces, followed by a linebreak, and then increases the indent level.
            When disposed, will decrease indent level, close the curly braces, and add another linebreak.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithCBlock(System.String)">
            <summary>
            Writes a text line, followed by a linebreak, then opens a C-style Block (Compound Statement) which starts with curly-braces, followed by a linebreak, and then increases the indent level.
            When disposed, will decrease indent level, close the curly braces, and add another linebreak.
            </summary>
            <param name="lineBeforeBlock"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WithJavascriptBlock(System.String)">
            <summary>
            Writes a text line, followed (without linebreaks) by the beginning of a javascript-style Block which starts with curly-braces, followed by a linebreak, and then increases the indent level.
            When disposed, will decrease indent level, close the curly braces, and add another linebreak.
            </summary>
            <param name="lineBeforeBlock"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.CodegenTextWriter.WriteWithIndents(System.String)">
            <summary>
            This is the "heart" of this class. Basically, we split any multi-line string, and write line by line. 
            Before writing each new line we write the indent block, which could for example be 8 spaces (4 spaces in first indent level and 4 spaces for second indent level),
            or 2 tabs (one for each indent level), or any combination.
            </summary>
            <param name="value"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CodegenCS.CodegenTextWriter.WriteFormattable(System.String,System.Object[])" -->
        <member name="M:CodegenCS.CodegenTextWriter.AdjustMultilineString(System.String)">
            <summary>
            Given a text block (multiple lines), this removes the left padding of the block, by calculating the minimum number of spaces which happens in EVERY line.
            Then, this method writes one by one each line, which in case will respect the current indent.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.AddItem(System.String,CodegenCS.OutputFileType,System.String)">
            <summary>
            Adds a single item, optionally dependent of a parent item (DependentUpon). 
            </summary>
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.RemoveUnusedDependentItems(System.String)">
            <summary>
            Given an item in the project, will remove all items which depend on this parent item, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.MSBuildProjectEditor.RemoveUnusedItems(System.String)">
            <summary>
            Given a folder in the project, will remove all items which are under this folder, except the items which were added using AddItem
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.Database.Execute(System.String,System.Object,System.Data.IDbTransaction,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Creates a raw SqlConnection to the database. This is for using Dapper or raw ADO.NET.
            Don't forget to wrap your connection inside a "using" statement, to automatically close/dispose connection at end:
            using (var conn = DB.CreateConnection())
            {
               ...
            }
            </summary>
            <returns></returns>
            <summary>
            Execute parameterized SQL
            </summary>
            <returns>Number of rows affected</returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Execute``1(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Execute parameterized SQL, returning the data typed as per T
            </summary>
            <returns>List of Entities of type T</returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Query``1(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
             Executes a query, returning the data typed as per T
            </summary>
            <returns>
            A sequence of data of the supplied type; if a basic type (int, string, etc) is
             queried then the data from the first column in assumed, otherwise an instance
             is created per row, and a direct column-name===member-name mapping is assumed
             (case insensitive).
            </returns>
        </member>
        <member name="M:CodegenCS.Utils.Database.Query(System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
             Return a sequence of dynamic objects      <para /> 
             Example:
             var tables = DB.Query("SELECT * FROM sys.tables");
             foreach(var table in tables) Response.WriteLine(table.Name);  <para /> 
            </summary>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Pluralize(System.String)">
            <summary>
                Pluralizes a word.
            </summary>
            <example>
                inflect.Pluralize("search").ShouldBe("searches");
                inflect.Pluralize("stack").ShouldBe("stacks");
                inflect.Pluralize("fish").ShouldBe("fish");
            </example>
            <param name="word">The word to pluralize.</param>
            <returns>The pluralized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Singularize(System.String)">
            <summary>
                Singularizes a word.
            </summary>
            <example>
                inflect.Singularize("searches").ShouldBe("search");
                inflect.Singularize("stacks").ShouldBe("stack");
                inflect.Singularize("fish").ShouldBe("fish");
            </example>
            <param name="word">The word to signularize.</param>
            <returns>The signularized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Titleise(System.String)">
            <summary>
                Titleises the word. (title => Title, the_brown_fox => TheBrownFox)
            </summary>
            <example>
                inflect.Titleise("some title").ShouldBe("Some Title");
                inflect.Titleise("some-title").ShouldBe("Some Title");
                inflect.Titleise("sometitle").ShouldBe("Sometitle");
                inflect.Titleise("some_title:_the_beginning").ShouldBe("Some Title: The Beginning");
            </example>
            <param name="word">The word to titleise.</param>
            <returns>The titleised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Humanise(System.String)">
            <summary>
                Humanizes the word.
            </summary>
            <example>
                inflect.Humanise("some_title").ShouldBe("Some title");
                inflect.Humanise("some-title").ShouldBe("Some-title");
                inflect.Humanise("Some_title").ShouldBe("Some title");
                inflect.Humanise("someTitle").ShouldBe("Sometitle");
                inflect.Humanise("someTitle_Another").ShouldBe("Sometitle another");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to humanise.</param>
            <returns>The humanized word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Pascalise(System.String)">
            <summary>
                Pascalises the word.
            </summary>
            <example>
                inflect.Pascalise("customer").ShouldBe("Customer");
                inflect.Pascalise("customer_name").ShouldBe("CustomerName");
                inflect.Pascalise("customer name").ShouldBe("CustomerName");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to pascalise.</param>
            <returns>The pascalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Camelise(System.String)">
            <summary>
                Camelises the word.
            </summary>
            <example>
                inflect.Camelise("Customer").ShouldBe("customer");
                inflect.Camelise("customer_name").ShouldBe("customerName");
                inflect.Camelise("customer_first_name").ShouldBe("customerFirstName");
                inflect.Camelise("customer name").ShouldBe("customer name");
            </example>
            <param name="lowercaseAndUnderscoredWord">The word to camelise.</param>
            <returns>The camelised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Underscore(System.String)">
            <summary>
                Underscores the word.
            </summary>
            <example>
                inflect.Underscore("SomeTitle").ShouldBe("some_title");
                inflect.Underscore("someTitle").ShouldBe("some_title");
                inflect.Underscore("some title that will be underscored").ShouldBe("some_title_that_will_be_underscored");
                inflect.Underscore("SomeTitleThatWillBeUnderscored").ShouldBe("some_title_that_will_be_underscored");
            </example>
            <param name="pascalCasedWord">The word to underscore.</param>
            <returns>The underscored word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Capitalise(System.String)">
            <summary>
                Capitalises the word.
            </summary>
            <example>
                inflect.Capitalise("some title").ShouldBe("Some title");
                inflect.Capitalise("some Title").ShouldBe("Some title");
                inflect.Capitalise("SOMETITLE").ShouldBe("Sometitle");
                inflect.Capitalise("someTitle").ShouldBe("Sometitle");
                inflect.Capitalise("some title goes here").ShouldBe("Some title goes here");
            </example>
            <param name="word">The word to capitalise.</param>
            <returns>The capitalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Uncapitalise(System.String)">
            <summary>
                Uncapitalises the word.
            </summary>
            <example>
                inflect.Uncapitalise("Some title").ShouldBe("some title");
                inflect.Uncapitalise("Some Title").ShouldBe("some Title");
                inflect.Uncapitalise("SOMETITLE").ShouldBe("sOMETITLE");
                inflect.Uncapitalise("someTitle").ShouldBe("someTitle");
                inflect.Uncapitalise("Some title goes here").ShouldBe("some title goes here");
            </example>
            <param name="word">The word to uncapitalise.</param>
            <returns>The uncapitalised word.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Ordinalise(System.String)">
            <summary>
                Ordinalises the number.
            </summary>
            <example>
                inflect.Ordinalise(0).ShouldBe("0th");
                inflect.Ordinalise(1).ShouldBe("1st");
                inflect.Ordinalise(2).ShouldBe("2nd");
                inflect.Ordinalise(3).ShouldBe("3rd");
                inflect.Ordinalise(101).ShouldBe("101st");
                inflect.Ordinalise(104).ShouldBe("104th");
                inflect.Ordinalise(1000).ShouldBe("1000th");
                inflect.Ordinalise(1001).ShouldBe("1001st");
            </example>
            <param name="number">The number to ordinalise.</param>
            <returns>The ordinalised number.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Ordinalise(System.Int32)">
            <summary>
                Ordinalises the number.
            </summary>
            <example>
                inflect.Ordinalise("0").ShouldBe("0th");
                inflect.Ordinalise("1").ShouldBe("1st");
                inflect.Ordinalise("2").ShouldBe("2nd");
                inflect.Ordinalise("3").ShouldBe("3rd");
                inflect.Ordinalise("100").ShouldBe("100th");
                inflect.Ordinalise("101").ShouldBe("101st");
                inflect.Ordinalise("1000").ShouldBe("1000th");
                inflect.Ordinalise("1001").ShouldBe("1001st");
            </example>
            <param name="number">The number to ordinalise.</param>
            <returns>The ordinalised number.</returns>
        </member>
        <member name="M:CodegenCS.Utils.IInflector.Dasherise(System.String)">
            <summary>
                Dasherises the word.
            </summary>
            <example>
                inflect.Dasherise("some_title").ShouldBe("some-title");
                inflect.Dasherise("some-title").ShouldBe("some-title");
                inflect.Dasherise("some_title_goes_here").ShouldBe("some-title-goes-here");
                inflect.Dasherise("some_title and_another").ShouldBe("some-title and-another");
            </example>
            <param name="underscoredWord">The word to dasherise.</param>
            <returns>The dasherised word.</returns>
        </member>
    </members>
</doc>

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace CodegenCS
{
    /// <summary>
    /// This text writer has some features to help code-generation tools:
    /// - Will keep track of "Indent Levels", and will write whitespace-indents accordingly to the current level.
    ///   It's possible to explicitly increase/decrease indent level
    ///   It's possible to change the IndentString
    ///   It's possible to increase level using "using (writer.WithIndent()) {...}".
    ///   There's a shortcut to start C-style blocks: using (writer.WithCStyleBlock($"public class {myClass}")). Will automatically start "{" and close with "}"
    ///   
    /// - Allows to execute "inline actions", which mean that writer will save the current cursor position, and will run the action which may write a string.
    ///   If the string has multiple lines, all lines starting from the second will "preserve" the same indent (cursor position) that was there when we started writing the first line.
    ///   This means that it's possible to embed blocks "inline", while preserving the correct indent where the block should start.
    ///    This allow us to use any kind of "template include" functions without having to manually control indentation.
    ///    In case CodegenTextWriter uses these inline actions to write string-interpolation-based templates, but we could also use Razor, Dotliquid, Scriban, or any other template engine.
    /// 
    /// - Allows to write complex templates using pure C# language and interpolated strings.
    ///   Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments. 
    ///   Since we also control indentation (and preserve indentation even when we run "inline actions" in the middle of the template), this works like a charm.
    ///   
    /// - For convenience, all multi-line string blocks will have the first empty line removed and Left Padding removed.
    ///   This means that you can write the multi-line strings with any number of padding spaces, and yet those spaces will be ignored - so you can align the 
    ///   generated code with the outer control code.
    /// </summary>
    public class CodegenTextWriter : TextWriter
    {
        #region Members
        protected readonly TextWriter _innerWriter;

        protected static readonly Regex _lineBreaksRegex = new Regex(@"(\r\n|\n|\r)", RegexOptions.Compiled);

        /// <summary>
        /// If true, will normalize line breaks by replacing different styles (\n, \r\n, \r, etc) by _innerWriter.NewLine
        /// </summary>
        protected bool _normalizeLineEndings = true;

        protected MultilineBehaviorType MultilineBehavior = MultilineBehaviorType.TrimLeftPaddingAndRemoveFirstEmptyLine;

        /// <summary>
        /// How multi-line text blocks are adjusted
        /// </summary>
        protected enum MultilineBehaviorType
        {
            None,
            /// <summary>
            /// Will remove the left padding of multi-line text blocks, by "untabbing" the block until some row "touches" the margin.
            /// </summary>
            TrimLeftPadding,
            /// <summary>
            /// Will remove left padding and will remove the first empty line
            /// </summary>
            TrimLeftPaddingAndRemoveFirstEmptyLine
        }

        /// <summary>
        /// This keeps tracks of what was written to the current line, NOT COUNTING indent-strings which were generated by this text writer.
        /// Example: if this text writer was already in IndentLevel 1 (4 spaces) when it started rendering a template, and the template opens a nested if block (adding 1 more indent level, totalling 8 spaces),
        /// This will be 4 (4 extra spaces not counting inherited indent).
        /// If we render an inner template (e.g. @Include ("SubTemplate")), the subtemplate should honor BOTH the current indent level and also the number of spaces before the template was included.
        /// </summary>

        StringBuilder _currentLine = new StringBuilder();
        bool _dontIndentCurrentLine = false; // when we're in the middle of a line and start an inline block (which could be multiline string), the first line don't need to be indented - only the next ones
        #endregion

        #region ctors
        public CodegenTextWriter()
        {
            _innerWriter = new StringWriter();
        }
        public CodegenTextWriter(string filePath)
        {
            Console.WriteLine(filePath);
            _innerWriter = new StreamWriter(filePath);
        }
        public CodegenTextWriter(TextWriter textWriter)
        {
            _innerWriter = textWriter;
        }
        #endregion

        #region Text Writer overrides
        public override string NewLine { get { return _innerWriter.NewLine; } set { _innerWriter.NewLine = value; } } // use NewLine from the most inner writer


        public override Encoding Encoding => Encoding.UTF8;

        public override void Close() => _innerWriter.Close();

        public override void Flush() => _innerWriter.Flush();
        public override string ToString() => _innerWriter.ToString();

        protected override void Dispose(bool disposing)
        {
            _innerWriter.Flush();
            _innerWriter.Dispose();
            base.Dispose(disposing);
        }
        #endregion

        #region Indent class
        internal class Indent : IDisposable
        {
            private readonly CodegenTextWriter _writer;
            private bool _disposed = false;
            private string _blockStart = null; // what to write immediately before we increase indent
            private string _blockEnd = null; // what to write immediately after we decrease indent
            // When we indent, we just get the IndentLevel of the writer, and increase it.
            public Indent(CodegenTextWriter writer)
            {
                _writer = writer;
                writer.IncreaseIndent();
            }
            public Indent(CodegenTextWriter writer, string blockStart, string blockEnd)
            {
                _writer = writer;
                _blockStart = blockStart;
                _blockEnd = blockEnd;
                _writer.WriteWithIndents(_blockStart);
                writer.IncreaseIndent();
            }

            // When we dispose, we just restore back the old level of the writer
            public void Dispose()
            {
                if (_disposed)
                {
                    throw new ObjectDisposedException(nameof(Indent));
                }
                _writer.DecreaseIndent();
                if (_blockEnd != null)
                    _writer.WriteWithIndents(_blockEnd);
            }
        }
        #endregion

        #region Indent-control: methods and members
        public Stack<string> _levelIndent = new Stack<string>(); // each level may have it's own indent.... e.g. one block may have "    ", while other may have "-- ", etc.
        public int IndentLevel { get { return _levelIndent.Count; } }
        public string IndentString { get; set; } = "    ";
        public void IncreaseIndent()
        {
            _levelIndent.Push(IndentString);
        }
        public void DecreaseIndent()
        {
            _levelIndent.Pop();
        }

        /// <summary>
        /// If the current line has some manually-written whitespace, this method will "save" current cursor position, and in case the inline action writes a multi-line text,
        /// the subsequent lines (after the first) will "preserve" the cursor position by adding this extra indent.
        /// ("manually-written whitespace" does not count the automatic indents written by this class).
        /// </summary>
        public void ExecuteInlineAction(Action inlineAction)
        {
            string indent = _currentLine.ToString();
            if (indent != null && indent.Length > 0 && string.IsNullOrWhiteSpace(indent))
            {
                _levelIndent.Push(indent); // we could convert tabs to spaces or vice-versa
                _dontIndentCurrentLine = true;
                _currentLine.Clear();
                inlineAction();
                _levelIndent.Pop();
            }
            else
            {
                inlineAction();
            }
        }

        /// <summary>
        /// Increases the indent level, and when disposed will decrease it.
        /// </summary>
        /// <returns></returns>
        public IDisposable WithIndent() => new Indent(this);

        /// <summary>
        /// Opens a C-style Block (Compound Statement) which starts with curly-braces, followed by a linebreak, and then increases the indent level.
        /// When disposed, will decrease indent level, close the curly braces, and add another linebreak.
        /// </summary>
        /// <returns></returns>
        public IDisposable WithCBlock() => new Indent(this, "{" + this.NewLine, "}" + this.NewLine);

        /// <summary>
        /// Writes a text line, followed by a linebreak, then opens a C-style Block (Compound Statement) which starts with curly-braces, followed by a linebreak, and then increases the indent level.
        /// When disposed, will decrease indent level, close the curly braces, and add another linebreak.
        /// </summary>
        /// <param name="lineBeforeBlock"></param>
        /// <returns></returns>
        public IDisposable WithCBlock(string lineBeforeBlock) => new Indent(this, lineBeforeBlock + this.NewLine + "{" + this.NewLine, "}" + this.NewLine);

        /// <summary>
        /// Writes a text line, followed (without linebreaks) by the beginning of a javascript-style Block which starts with curly-braces, followed by a linebreak, and then increases the indent level.
        /// When disposed, will decrease indent level, close the curly braces, and add another linebreak.
        /// </summary>
        /// <param name="lineBeforeBlock"></param>
        /// <returns></returns>
        public IDisposable WithJavascriptBlock(string lineBeforeBlock) => new Indent(this, lineBeforeBlock + "{" + this.NewLine, "}" + this.NewLine);


        public void WriteIndent()
        {
            string indent = string.Join("", _levelIndent.Reverse().ToList());
            WriteRaw(indent);
            _currentLine.Clear();
        }
        #endregion

        #region NotImplemented Writes (based on char[])
        public override void Write(char[] buffer)
        {
            throw new NotImplementedException();
        }
        public override void Write(char[] buffer, int index, int count)
        {
            throw new NotImplementedException();
        }
        public override void WriteLine(char[] buffer)
        {
            throw new NotImplementedException();
        }
        public override void WriteLine(char[] buffer, int index, int count)
        {
            throw new NotImplementedException();
        }
        #endregion

        #region Raw Writes (to _innerWriter) - these don't add any indent
        private void WriteRaw(string value)
        {
            _innerWriter.Write(value);
            System.Diagnostics.Debug.Write(value);
        }
        #endregion

        #region WriteWithIndents(string value): writes line by line, and writes the indent strings before each new line
        /// <summary>
        /// This is the "heart" of this class. Basically, we split any multi-line string, and write line by line. 
        /// Before writing each new line we write the indent block, which could for example be 8 spaces (4 spaces in first indent level and 4 spaces for second indent level),
        /// or 2 tabs (one for each indent level), or any combination.
        /// </summary>
        /// <param name="value"></param>
        protected void WriteWithIndents(string value)
        {
            if (string.IsNullOrEmpty(value))
                return;

            var matches = _lineBreaksRegex.Matches(value);

            int lastPos = 0;
            for (int i = 0; i < matches.Count; i++)
            {
                string line = value.Substring(lastPos, matches[i].Index - lastPos);
                string lineBreak = value.Substring(matches[i].Index, matches[i].Length);
                lastPos = matches[i].Index + matches[i].Length;

                // if _dontIndentCurrentLine is set, it's because we're starting an inner block right "at cursor position"-  no need to indent again - we're already positioned!
                if (line.Length > 0 && _currentLine.Length == 0 && !_dontIndentCurrentLine)
                    WriteIndent();

                WriteRaw(line);
                if (_normalizeLineEndings)
                    WriteRaw(NewLine);
                else
                    WriteRaw(lineBreak);
                _currentLine.Clear();
                _dontIndentCurrentLine = false;
            }
            string lastLine = value.Substring(lastPos);

            if (lastLine.Length > 0 && _currentLine.Length == 0 && !_dontIndentCurrentLine)
                WriteIndent();
            WriteRaw(lastLine);
            _currentLine.Clear().Append(lastLine);
            _dontIndentCurrentLine = false;
        }
        #endregion

        #region WriteFormattable(string format, params object[] arguments) - Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments. 
        /// <summary>
        /// This is the "heart" of this class. Basically, we split any interpolated string, and write block by block, doing lazy-evaluation of arguments. 
        /// The idea of writing Func<FormattableString> is that we do NOT evaluate the {arguments} BEFORE the outer string is being written - they are only evaluated when needed
        /// so we can capture the cursor position in current line, and preserve-it if the arguments render multi-line strings
        /// </summary>
        protected void WriteFormattable(string format, params object[] arguments)
        {
            //https://www.meziantou.net/interpolated-strings-advanced-usages.htm
            var matches = Regex.Matches(format, @"{\d}");
            int lastPos = 0;
            for (int i = 0; i < matches.Count; i++)
            {
                // unescape escaped curly braces
                string text = format.Substring(lastPos, matches[i].Index - lastPos).Replace("{{", "{").Replace("}}", "}");
                WriteWithIndents(text);
                // arguments[i] may not work because same argument can be used multiple times
                var arg = arguments[int.Parse(matches[i].Value.Substring(1, 1))];

                Type[] interfaceTypes = arg.GetType().GetInterfaces();
                Type interfaceType;
                if ((interfaceType = interfaceTypes.SingleOrDefault(t => 
                    t.IsGenericType && 
                    t.GetGenericTypeDefinition() == typeof(IEnumerable<>) &&
                    t.GetGenericArguments()[0].IsAssignableFrom(typeof(FormattableString))
                    )) != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        IEnumerable<FormattableString> list = (IEnumerable<FormattableString>)arg;
                        for(int j = 0; j < list.Count(); j++)
                        {
                            FormattableString item = list.ElementAt(j);
                            Write(item);
                            if (j < list.Count() - 1)
                                WriteLine();
                        }
                    });
                }
                else if ((interfaceType = interfaceTypes.SingleOrDefault(t =>
                    t.IsGenericType &&
                    t.GetGenericTypeDefinition() == typeof(IEnumerable<>) &&
                    t.GetGenericArguments()[0].IsGenericType &&
                    t.GetGenericArguments()[0].GetGenericTypeDefinition() == typeof(Func<>) &&
                    t.GetGenericArguments()[0].GetGenericArguments()[0].IsAssignableFrom(typeof(FormattableString))
                    )) != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        IEnumerable<Func<FormattableString>> list = (IEnumerable<Func<FormattableString>>)arg;
                        for (int j = 0; j < list.Count(); j++)
                        {
                            Func<FormattableString> item = list.ElementAt(j);
                            Write(item);
                            if (j < list.Count() - 1)
                                WriteLine();
                        }
                    });
                }
                else if ((interfaceType = interfaceTypes.SingleOrDefault(t =>
                    t.IsGenericType &&
                    t.GetGenericTypeDefinition() == typeof(IEnumerable<>) &&
                    t.GetGenericArguments()[0].IsGenericType &&
                    t.GetGenericArguments()[0].GetGenericTypeDefinition() == typeof(Func<>) &&
                    t.GetGenericArguments()[0].GetGenericArguments()[0].IsAssignableFrom(typeof(string))
                    )) != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        IEnumerable<Func<string>> list = (IEnumerable<Func<string>>)arg;
                        for (int j = 0; j < list.Count(); j++)
                        {
                            Func<string> item = list.ElementAt(j);
                            Write(item);
                            if (j < list.Count() - 1)
                                WriteLine();
                        }
                    });
                }
                else if ((interfaceType = interfaceTypes.SingleOrDefault(t =>
                    t.IsGenericType &&
                    t.GetGenericTypeDefinition() == typeof(IEnumerable<>) &&
                    t.GetGenericArguments()[0].IsAssignableFrom(typeof(string))
                    )) != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        IEnumerable<string> list = (IEnumerable<string>)arg;
                        for (int j = 0; j < list.Count(); j++)
                        {
                            string item = list.ElementAt(j);
                            Write(item);
                            if (j < list.Count() - 1)
                                WriteLine();
                        }
                    });

                }
                else if (arg as FormattableString != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        FormattableString subText = (FormattableString)arg;
                        Write(subText);
                    });
                }
                else if (arg as Func<FormattableString> != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        Func<FormattableString> subText = ((Func<FormattableString>)arg);
                        Write(subText);
                    });
                }
                else if (arg as Action<CodegenTextWriter> != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        Action<CodegenTextWriter> action = ((Action<CodegenTextWriter>)arg);
                        action(this);
                    });
                }
                else if (arg as Action<TextWriter> != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        Action<TextWriter> action = ((Action<TextWriter>)arg);
                        action(this);
                    });
                }
                else if (arg as Func<string> != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        string exec = ((Func<string>)arg)();
                        Write(exec);
                    });
                }
                else if (arg as string != null)
                {
                    ExecuteInlineAction(() =>
                    {
                        string subText = ((string)arg);
                        Write(subText);
                    });
                }
                else
                {
                    ExecuteInlineAction(() =>
                    {
                        Write(arg.ToString());
                    });
                }

                lastPos = matches[i].Index + matches[i].Length;
            }
            string lastPart = format.Substring(lastPos).Replace("{{", "{").Replace("}}", "}");
            WriteWithIndents(lastPart);
        }
        #endregion

        #region public Write/WriteLine methods for formattable strings (which basically are shortcuts to WriteFormattable())
        public void Write(FormattableString formattable)
        {
            string format = formattable.Format;
            format = AdjustMultilineString(format);
            WriteFormattable(format, formattable.GetArguments());
        }
        public void WriteLine(FormattableString formattable)
        {
            Write(formattable);
            WriteLine();
        }

        public override void Write(string format, params object[] arguments)
        {
            if (string.IsNullOrEmpty(format))
                return;
            format = AdjustMultilineString(format);

            WriteFormattable(format, arguments);
        }
        public override void WriteLine(string format, params object[] arguments)
        {
            Write(format, arguments);
            WriteLine();
        }
        public void Write(Func<FormattableString> fnFormattable)
        {
            FormattableString formattable = fnFormattable();
            Write(formattable);
        }
        public void WriteLine(Func<FormattableString> fnFormattable)
        {
            Write(fnFormattable());
            WriteLine();
        }
        #endregion


        #region public Write/WriteLine methods (which basically are shortcuts to WriteWithIndents())
        public override void WriteLine()
        {
            WriteRaw(this.NewLine);
            _currentLine.Clear();
        }
        public override void Write(string value)
        {
            if (!string.IsNullOrEmpty(value))
            {
                value = AdjustMultilineString(value);
                WriteWithIndents(value);
            }
        }
        public void Write(Func<string> fnString)
        {
            string value = fnString();
            Write(value);
        }
        public void WriteLine(Func<string> fnString)
        {
            Write(fnString());
            WriteLine();
        }

        public override void WriteLine(string value)
        {
            Write(value);
            WriteLine();
        }
        #endregion

        #region Helpers for convenient string usage: TrimLeftPadding(string) and TrimFirstEmptyLine(string)
        /// <summary>
        /// Given a text block (multiple lines), this removes the left padding of the block, by calculating the minimum number of spaces which happens in EVERY line.
        /// Then, this method writes one by one each line, which in case will respect the current indent.
        /// </summary>
        /// <param name="block"></param>
        /// <returns></returns>
        protected string AdjustMultilineString(string block)
        {
            if (MultilineBehavior == MultilineBehaviorType.None)
                return block;
            string[] parts = _lineBreaksRegex.Split(block);
            if (parts.Length <= 1) // no linebreaks at all
                return block;
            var nonEmptyLines = parts.Where(line => line.TrimEnd().Length > 0).ToList();
            if (nonEmptyLines.Count <= 1) // if there's not at least 2 non-empty lines, assume that we don't need to adjust anything
                return block;

            if (MultilineBehavior == MultilineBehaviorType.TrimLeftPaddingAndRemoveFirstEmptyLine)
            {
                Match m = _lineBreaksRegex.Match(block);
                if (m != null && m.Success && m.Index == 0)
                {
                    block = block.Substring(m.Length); // remove first empty line
                    parts = _lineBreaksRegex.Split(block);
                    nonEmptyLines = parts.Where(line => line.TrimEnd().Length > 0).ToList();
                }
            }


            int minNumberOfSpaces = nonEmptyLines.Select(nonEmptyLine => nonEmptyLine.Length - nonEmptyLine.TrimStart().Length).Min();

            StringBuilder sb = new StringBuilder();

            var matches = _lineBreaksRegex.Matches(block);
            int lastPos = 0;
            for (int i = 0; i < matches.Count; i++)
            {
                string line = block.Substring(lastPos, matches[i].Index - lastPos);
                string lineBreak = block.Substring(matches[i].Index, matches[i].Length);
                lastPos = matches[i].Index + matches[i].Length;

                sb.Append(line.Substring(Math.Min(line.Length, minNumberOfSpaces)));
                sb.Append(lineBreak);
            }
            string lastLine = block.Substring(lastPos);
            sb.Append(lastLine.Substring(Math.Min(lastLine.Length, minNumberOfSpaces)));

            return sb.ToString();
        }
        #endregion

    }
}
